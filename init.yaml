# headless service
apiVersion: v1
kind: Service
metadata: 
  name: statefulset-redis-headless-service
spec:
  clusterIP: None
  ports:
  - name: main
    protocol: TCP
    port: 6379
  selector:
    app: statefulset-redis

---
#dynamic pvc: storage class
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: storage-class-pvc
provisioner: kubernetes.io/glusterfs
parameters:
  resturl: "http://192.168.1.91:8080"
  restauthenabled: "false"

    
---
#configmap
apiVersion: v1
data:
  port: "6379"
  sentinel.config: |
    port 26379
    dir /tmp
    sentinel monitor mymaster statefulset-redis-0.statefulset-redis-headless-service.default.svc.cluster.local 6379 2
    sentinel down-after-milliseconds mymaster 30000
    sentinel parallel-syncs mymaster 1
    sentinel failover-timeout mymaster 180000
  redis.config: "# Redis configuration file example.\n#\n# Note that in order to read
    the configuration file, Redis must be\n# started with the file path as first argument:\n#\n#
    ./redis-server /path/to/redis.conf\n\n# Note on units: when memory size is needed,
    it is possible to specify\n# it in the usual form of 1k 5GB 4M and so forth:\n#\n#
    1k => 1000 bytes\n# 1kb => 1024 bytes\n# 1m => 1000000 bytes\n# 1mb => 1024*1024
    bytes\n# 1g => 1000000000 bytes\n# 1gb => 1024*1024*1024 bytes\n#\n# units are
    case insensitive so 1GB 1Gb 1gB are all the same.\n\n##################################
    INCLUDES ###################################\n\n# Include one or more other config
    files here.  This is useful if you\n# have a standard template that goes to all
    Redis servers but also need\n# to customize a few per-server settings.  Include
    files can include\n# other files, so use this wisely.\n#\n# Notice option \"include\"
    won't be rewritten by command \"CONFIG REWRITE\"\n# from admin or Redis Sentinel.
    Since Redis always uses the last processed\n# line as value of a configuration
    directive, you'd better put includes\n# at the beginning of this file to avoid
    overwriting config change at runtime.\n#\n# If instead you are interested in using
    includes to override configuration\n# options, it is better to use include as
    the last line.\n#\n# include /path/to/local.conf\n# include /path/to/other.conf\n\n##################################
    MODULES #####################################\n\n# Load modules at startup. If
    the server is not able to load modules\n# it will abort. It is possible to use
    multiple loadmodule directives.\n#\n# loadmodule /path/to/my_module.so\n# loadmodule
    /path/to/other_module.so\n\n################################## NETWORK #####################################\n\n#
    By default, if no \"bind\" configuration directive is specified, Redis listens\n#
    for connections from all the network interfaces available on the server.\n# It
    is possible to listen to just one or multiple selected interfaces using\n# the
    \"bind\" configuration directive, followed by one or more IP addresses.\n#\n#
    Examples:\n#\n# bind 192.168.1.100 10.0.0.1\n# bind 127.0.0.1 ::1\n#\n# ~~~ WARNING
    ~~~ If the computer running Redis is directly exposed to the\n# internet, binding
    to all the interfaces is dangerous and will expose the\n# instance to everybody
    on the internet. So by default we uncomment the\n# following bind directive, that
    will force Redis to listen only into\n# the IPv4 lookback interface address (this
    means Redis will be able to\n# accept connections only from clients running into
    the same computer it\n# is running).\n#\n# IF YOU ARE SURE YOU WANT YOUR INSTANCE
    TO LISTEN TO ALL THE INTERFACES\n# JUST COMMENT THE FOLLOWING LINE.\n# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nbind
    0.0.0.0\n\n# Protected mode is a layer of security protection, in order to avoid
    that\n# Redis instances left open on the internet are accessed and exploited.\n#\n#
    When protected mode is on and if:\n#\n# 1) The server is not binding explicitly
    to a set of addresses using the\n#    \"bind\" directive.\n# 2) No password is
    configured.\n#\n# The server only accepts connections from clients connecting
    from the\n# IPv4 and IPv6 loopback addresses 127.0.0.1 and ::1, and from Unix
    domain\n# sockets.\n#\n# By default protected mode is enabled. You should disable
    it only if\n# you are sure you want clients from other hosts to connect to Redis\n#
    even if no authentication is configured, nor a specific set of interfaces\n# are
    explicitly listed using the \"bind\" directive.\nprotected-mode yes\n\n# Accept
    connections on the specified port, default is 6379 (IANA #815344).\n# If port
    0 is specified Redis will not listen on a TCP socket.\nport 6379\n\n# TCP listen()
    backlog.\n#\n# In high requests-per-second environments you need an high backlog
    in order\n# to avoid slow clients connections issues. Note that the Linux kernel\n#
    will silently truncate it to the value of /proc/sys/net/core/somaxconn so\n# make
    sure to raise both the value of somaxconn and tcp_max_syn_backlog\n# in order
    to get the desired effect.\ntcp-backlog 511\n\n# Unix socket.\n#\n# Specify the
    path for the Unix socket that will be used to listen for\n# incoming connections.
    There is no default, so Redis will not listen\n# on a unix socket when not specified.\n#\n#
    unixsocket /tmp/redis.sock\n# unixsocketperm 700\n\n# Close the connection after
    a client is idle for N seconds (0 to disable)\ntimeout 0\n\n# TCP keepalive.\n#\n#
    If non-zero, use SO_KEEPALIVE to send TCP ACKs to clients in absence\n# of communication.
    This is useful for two reasons:\n#\n# 1) Detect dead peers.\n# 2) Take the connection
    alive from the point of view of network\n#    equipment in the middle.\n#\n# On
    Linux, the specified value (in seconds) is the period used to send ACKs.\n# Note
    that to close the connection the double of the time is needed.\n# On other kernels
    the period depends on the kernel configuration.\n#\n# A reasonable value for this
    option is 300 seconds, which is the new\n# Redis default starting with Redis 3.2.1.\ntcp-keepalive
    300\n\n################################# GENERAL #####################################\n\n#
    By default Redis does not run as a daemon. Use 'yes' if you need it.\n# Note that
    Redis will write a pid file in /var/run/redis.pid when daemonized.\ndaemonize
    yes\n\n# If you run Redis from upstart or systemd, Redis can interact with your\n#
    supervision tree. Options:\n#   supervised no      - no supervision interaction\n#
    \  supervised upstart - signal upstart by putting Redis into SIGSTOP mode\n#   supervised
    systemd - signal systemd by writing READY=1 to $NOTIFY_SOCKET\n#   supervised
    auto    - detect upstart or systemd method based on\n#                        UPSTART_JOB
    or NOTIFY_SOCKET environment variables\n# Note: these supervision methods only
    signal \"process is ready.\"\n#       They do not enable continuous liveness pings
    back to your supervisor.\nsupervised no\n\n# If a pid file is specified, Redis
    writes it where specified at startup\n# and removes it at exit.\n#\n# When the
    server runs non daemonized, no pid file is created if none is\n# specified in
    the configuration. When the server is daemonized, the pid file\n# is used even
    if not specified, defaulting to \"/var/run/redis.pid\".\n#\n# Creating a pid file
    is best effort: if Redis is not able to create it\n# nothing bad happens, the
    server will start and run normally.\npidfile /var/run/redis_6379.pid\n\n# Specify
    the server verbosity level.\n# This can be one of:\n# debug (a lot of information,
    useful for development/testing)\n# verbose (many rarely useful info, but not a
    mess like the debug level)\n# notice (moderately verbose, what you want in production
    probably)\n# warning (only very important / critical messages are logged)\nloglevel
    notice\n\n# Specify the log file name. Also the empty string can be used to force\n#
    Redis to log on the standard output. Note that if you use standard\n# output for
    logging but daemonize, logs will be sent to /dev/null\nlogfile \"\"\n\n# To enable
    logging to the system logger, just set 'syslog-enabled' to yes,\n# and optionally
    update the other syslog parameters to suit your needs.\n# syslog-enabled no\n\n#
    Specify the syslog identity.\n# syslog-ident redis\n\n# Specify the syslog facility.
    Must be USER or between LOCAL0-LOCAL7.\n# syslog-facility local0\n\n# Set the
    number of databases. The default database is DB 0, you can select\n# a different
    one on a per-connection basis using SELECT <dbid> where\n# dbid is a number between
    0 and 'databases'-1\ndatabases 16\n\n# By default Redis shows an ASCII art logo
    only when started to log to the\n# standard output and if the standard output
    is a TTY. Basically this means\n# that normally a logo is displayed only in interactive
    sessions.\n#\n# However it is possible to force the pre-4.0 behavior and always
    show a\n# ASCII art logo in startup logs by setting the following option to yes.\nalways-show-logo
    yes\n\n################################ SNAPSHOTTING  ################################\n#\n#
    Save the DB on disk:\n#\n#   save <seconds> <changes>\n#\n#   Will save the DB
    if both the given number of seconds and the given\n#   number of write operations
    against the DB occurred.\n#\n#   In the example below the behaviour will be to
    save:\n#   after 900 sec (15 min) if at least 1 key changed\n#   after 300 sec
    (5 min) if at least 10 keys changed\n#   after 60 sec if at least 10000 keys changed\n#\n#
    \  Note: you can disable saving completely by commenting out all \"save\" lines.\n#\n#
    \  It is also possible to remove all the previously configured save\n#   points
    by adding a save directive with a single empty string argument\n#   like in the
    following example:\n#\n#   save \"\"\n\nsave 900 1\nsave 300 10\nsave 60 10000\n\n#
    By default Redis will stop accepting writes if RDB snapshots are enabled\n# (at
    least one save point) and the latest background save failed.\n# This will make
    the user aware (in a hard way) that data is not persisting\n# on disk properly,
    otherwise chances are that no one will notice and some\n# disaster will happen.\n#\n#
    If the background saving process will start working again Redis will\n# automatically
    allow writes again.\n#\n# However if you have setup your proper monitoring of
    the Redis server\n# and persistence, you may want to disable this feature so that
    Redis will\n# continue to work as usual even if there are problems with disk,\n#
    permissions, and so forth.\nstop-writes-on-bgsave-error yes\n\n# Compress string
    objects using LZF when dump .rdb databases?\n# For default that's set to 'yes'
    as it's almost always a win.\n# If you want to save some CPU in the saving child
    set it to 'no' but\n# the dataset will likely be bigger if you have compressible
    values or keys.\nrdbcompression yes\n\n# Since version 5 of RDB a CRC64 checksum
    is placed at the end of the file.\n# This makes the format more resistant to corruption
    but there is a performance\n# hit to pay (around 10%) when saving and loading
    RDB files, so you can disable it\n# for maximum performances.\n#\n# RDB files
    created with checksum disabled have a checksum of zero that will\n# tell the loading
    code to skip the check.\nrdbchecksum yes\n\n# The filename where to dump the DB\ndbfilename
    node.rdb\n\n# The working directory.\n#\n# The DB will be written inside this
    directory, with the filename specified\n# above using the 'dbfilename' configuration
    directive.\n#\n# The Append Only File will also be created inside this directory.\n#\n#
    Note that you must specify a directory here, not a file name.\ndir /var/run/redis/data\n\n#################################
    REPLICATION #################################\n\n# Master-Slave replication. Use
    slaveof to make a Redis instance a copy of\n# another Redis server. A few things
    to understand ASAP about Redis replication.\n#\n# 1) Redis replication is asynchronous,
    but you can configure a master to\n#    stop accepting writes if it appears to
    be not connected with at least\n#    a given number of slaves.\n# 2) Redis slaves
    are able to perform a partial resynchronization with the\n#    master if the replication
    link is lost for a relatively small amount of\n#    time. You may want to configure
    the replication backlog size (see the next\n#    sections of this file) with a
    sensible value depending on your needs.\n# 3) Replication is automatic and does
    not need user intervention. After a\n#    network partition slaves automatically
    try to reconnect to masters\n#    and resynchronize with them.\n#\n# slaveof 127.0.0.1
    12345\n\n# If the master is password protected (using the \"requirepass\" configuration\n#
    directive below) it is possible to tell the slave to authenticate before\n# starting
    the replication synchronization process, otherwise the master will\n# refuse the
    slave request.\n#\n# requirepass johnnyredis\n\n# When a slave loses its connection
    with the master, or when the replication\n# is still in progress, the slave can
    act in two different ways:\n#\n# 1) if slave-serve-stale-data is set to 'yes'
    (the default) the slave will\n#    still reply to client requests, possibly with
    out of date data, or the\n#    data set may just be empty if this is the first
    synchronization.\n#\n# 2) if slave-serve-stale-data is set to 'no' the slave will
    reply with\n#    an error \"SYNC with master in progress\" to all the kind of
    commands\n#    but to INFO and SLAVEOF.\n#\nslave-serve-stale-data yes\n\n# You
    can configure a slave instance to accept writes or not. Writing against\n# a slave
    instance may be useful to store some ephemeral data (because data\n# written on
    a slave will be easily deleted after resync with the master) but\n# may also cause
    problems if clients are writing to it because of a\n# misconfiguration.\n#\n#
    Since Redis 2.6 by default slaves are read-only.\n#\n# Note: read only slaves
    are not designed to be exposed to untrusted clients\n# on the internet. It's just
    a protection layer against misuse of the instance.\n# Still a read only slave
    exports by default all the administrative commands\n# such as CONFIG, DEBUG, and
    so forth. To a limited extent you can improve\n# security of read only slaves
    using 'rename-command' to shadow all the\n# administrative / dangerous commands.\nslave-read-only
    yes\n\n# Replication SYNC strategy: disk or socket.\n#\n# -------------------------------------------------------\n#
    WARNING: DISKLESS REPLICATION IS EXPERIMENTAL CURRENTLY\n# -------------------------------------------------------\n#\n#
    New slaves and reconnecting slaves that are not able to continue the replication\n#
    process just receiving differences, need to do what is called a \"full\n# synchronization\".
    An RDB file is transmitted from the master to the slaves.\n# The transmission
    can happen in two different ways:\n#\n# 1) Disk-backed: The Redis master creates
    a new process that writes the RDB\n#                 file on disk. Later the file
    is transferred by the parent\n#                 process to the slaves incrementally.\n#
    2) Diskless: The Redis master creates a new process that directly writes the\n#
    \             RDB file to slave sockets, without touching the disk at all.\n#\n#
    With disk-backed replication, while the RDB file is generated, more slaves\n#
    can be queued and served with the RDB file as soon as the current child producing\n#
    the RDB file finishes its work. With diskless replication instead once\n# the
    transfer starts, new slaves arriving will be queued and a new transfer\n# will
    start when the current one terminates.\n#\n# When diskless replication is used,
    the master waits a configurable amount of\n# time (in seconds) before starting
    the transfer in the hope that multiple slaves\n# will arrive and the transfer
    can be parallelized.\n#\n# With slow disks and fast (large bandwidth) networks,
    diskless replication\n# works better.\nrepl-diskless-sync no\n\n# When diskless
    replication is enabled, it is possible to configure the delay\n# the server waits
    in order to spawn the child that transfers the RDB via socket\n# to the slaves.\n#\n#
    This is important since once the transfer starts, it is not possible to serve\n#
    new slaves arriving, that will be queued for the next RDB transfer, so the server\n#
    waits a delay in order to let more slaves arrive.\n#\n# The delay is specified
    in seconds, and by default is 5 seconds. To disable\n# it entirely just set it
    to 0 seconds and the transfer will start ASAP.\nrepl-diskless-sync-delay 5\n\n#
    Slaves send PINGs to server in a predefined interval. It's possible to change\n#
    this interval with the repl_ping_slave_period option. The default value is 10\n#
    seconds.\n#\n# repl-ping-slave-period 10\n\n# The following option sets the replication
    timeout for:\n#\n# 1) Bulk transfer I/O during SYNC, from the point of view of
    slave.\n# 2) Master timeout from the point of view of slaves (data, pings).\n#
    3) Slave timeout from the point of view of masters (REPLCONF ACK pings).\n#\n#
    It is important to make sure that this value is greater than the value\n# specified
    for repl-ping-slave-period otherwise a timeout will be detected\n# every time
    there is low traffic between the master and the slave.\n#\n# repl-timeout 60\n\n#
    Disable TCP_NODELAY on the slave socket after SYNC?\n#\n# If you select \"yes\"
    Redis will use a smaller number of TCP packets and\n# less bandwidth to send data
    to slaves. But this can add a delay for\n# the data to appear on the slave side,
    up to 40 milliseconds with\n# Linux kernels using a default configuration.\n#\n#
    If you select \"no\" the delay for data to appear on the slave side will\n# be
    reduced but more bandwidth will be used for replication.\n#\n# By default we optimize
    for low latency, but in very high traffic conditions\n# or when the master and
    slaves are many hops away, turning this to \"yes\" may\n# be a good idea.\nrepl-disable-tcp-nodelay
    no\n\n# Set the replication backlog size. The backlog is a buffer that accumulates\n#
    slave data when slaves are disconnected for some time, so that when a slave\n#
    wants to reconnect again, often a full resync is not needed, but a partial\n#
    resync is enough, just passing the portion of data the slave missed while\n# disconnected.\n#\n#
    The bigger the replication backlog, the longer the time the slave can be\n# disconnected
    and later be able to perform a partial resynchronization.\n#\n# The backlog is
    only allocated once there is at least a slave connected.\n#\n# repl-backlog-size
    1mb\n\n# After a master has no longer connected slaves for some time, the backlog\n#
    will be freed. The following option configures the amount of seconds that\n# need
    to elapse, starting from the time the last slave disconnected, for\n# the backlog
    buffer to be freed.\n#\n# Note that slaves never free the backlog for timeout,
    since they may be\n# promoted to masters later, and should be able to correctly
    \"partially\n# resynchronize\" with the slaves: hence they should always accumulate
    backlog.\n#\n# A value of 0 means to never release the backlog.\n#\n# repl-backlog-ttl
    3600\n\n# The slave priority is an integer number published by Redis in the INFO
    output.\n# It is used by Redis Sentinel in order to select a slave to promote
    into a\n# master if the master is no longer working correctly.\n#\n# A slave with
    a low priority number is considered better for promotion, so\n# for instance if
    there are three slaves with priority 10, 100, 25 Sentinel will\n# pick the one
    with priority 10, that is the lowest.\n#\n# However a special priority of 0 marks
    the slave as not able to perform the\n# role of master, so a slave with priority
    of 0 will never be selected by\n# Redis Sentinel for promotion.\n#\n# By default
    the priority is 100.\nslave-priority 100\n\n# It is possible for a master to stop
    accepting writes if there are less than\n# N slaves connected, having a lag less
    or equal than M seconds.\n#\n# The N slaves need to be in \"online\" state.\n#\n#
    The lag in seconds, that must be <= the specified value, is calculated from\n#
    the last ping received from the slave, that is usually sent every second.\n#\n#
    This option does not GUARANTEE that N replicas will accept the write, but\n# will
    limit the window of exposure for lost writes in case not enough slaves\n# are
    available, to the specified number of seconds.\n#\n# For example to require at
    least 3 slaves with a lag <= 10 seconds use:\n#\n# min-slaves-to-write 3\n# min-slaves-max-lag
    10\n#\n# Setting one or the other to 0 disables the feature.\n#\n# By default
    min-slaves-to-write is set to 0 (feature disabled) and\n# min-slaves-max-lag is
    set to 10.\n\n# A Redis master is able to list the address and port of the attached\n#
    slaves in different ways. For example the \"INFO replication\" section\n# offers
    this information, which is used, among other tools, by\n# Redis Sentinel in order
    to discover slave instances.\n# Another place where this info is available is
    in the output of the\n# \"ROLE\" command of a master.\n#\n# The listed IP and
    address normally reported by a slave is obtained\n# in the following way:\n#\n#
    \  IP: The address is auto detected by checking the peer address\n#   of the socket
    used by the slave to connect with the master.\n#\n#   Port: The port is communicated
    by the slave during the replication\n#   handshake, and is normally the port that
    the slave is using to\n#   list for connections.\n#\n# However when port forwarding
    or Network Address Translation (NAT) is\n# used, the slave may be actually reachable
    via different IP and port\n# pairs. The following two options can be used by a
    slave in order to\n# report to its master a specific set of IP and port, so that
    both INFO\n# and ROLE will report those values.\n#\n# There is no need to use
    both the options if you need to override just\n# the port or the IP address.\n#\n#
    slave-announce-ip 5.5.5.5\n# slave-announce-port 1234\n\n##################################
    SECURITY ###################################\n\n# Require clients to issue AUTH
    <PASSWORD> before processing any other\n# commands.  This might be useful in environments
    in which you do not trust\n# others with access to the host running redis-server.\n#\n#
    This should stay commented out for backward compatibility and because most\n#
    people do not need auth (e.g. they run their own servers).\n#\n# Warning: since
    Redis is pretty fast an outside user can try up to\n# 150k passwords per second
    against a good box. This means that you should\n# use a very strong password otherwise
    it will be very easy to break.\n#\n# requirepass foobared\n\n# Command renaming.\n#\n#
    It is possible to change the name of dangerous commands in a shared\n# environment.
    For instance the CONFIG command may be renamed into something\n# hard to guess
    so that it will still be available for internal-use tools\n# but not available
    for general clients.\n#\n# Example:\n#\n# rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52\n#\n#
    It is also possible to completely kill a command by renaming it into\n# an empty
    string:\n#\n# rename-command CONFIG \"\"\n#\n# Please note that changing the name
    of commands that are logged into the\n# AOF file or transmitted to slaves may
    cause problems.\n\n################################### CLIENTS ####################################\n\n#
    Set the max number of connected clients at the same time. By default\n# this limit
    is set to 10000 clients, however if the Redis server is not\n# able to configure
    the process file limit to allow for the specified limit\n# the max number of allowed
    clients is set to the current file limit\n# minus 32 (as Redis reserves a few
    file descriptors for internal uses).\n#\n# Once the limit is reached Redis will
    close all the new connections sending\n# an error 'max number of clients reached'.\n#\n#
    maxclients 10000\n\n############################## MEMORY MANAGEMENT ################################\n\n#
    Set a memory usage limit to the specified amount of bytes.\n# When the memory
    limit is reached Redis will try to remove keys\n# according to the eviction policy
    selected (see maxmemory-policy).\n#\n# If Redis can't remove keys according to
    the policy, or if the policy is\n# set to 'noeviction', Redis will start to reply
    with errors to commands\n# that would use more memory, like SET, LPUSH, and so
    on, and will continue\n# to reply to read-only commands like GET.\n#\n# This option
    is usually useful when using Redis as an LRU or LFU cache, or to\n# set a hard
    memory limit for an instance (using the 'noeviction' policy).\n#\n# WARNING: If
    you have slaves attached to an instance with maxmemory on,\n# the size of the
    output buffers needed to feed the slaves are subtracted\n# from the used memory
    count, so that network problems / resyncs will\n# not trigger a loop where keys
    are evicted, and in turn the output\n# buffer of slaves is full with DELs of keys
    evicted triggering the deletion\n# of more keys, and so forth until the database
    is completely emptied.\n#\n# In short... if you have slaves attached it is suggested
    that you set a lower\n# limit for maxmemory so that there is some free RAM on
    the system for slave\n# output buffers (but this is not needed if the policy is
    'noeviction').\n#\n# maxmemory <bytes>\n\n# MAXMEMORY POLICY: how Redis will select
    what to remove when maxmemory\n# is reached. You can select among five behaviors:\n#\n#
    volatile-lru -> Evict using approximated LRU among the keys with an expire set.\n#
    allkeys-lru -> Evict any key using approximated LRU.\n# volatile-lfu -> Evict
    using approximated LFU among the keys with an expire set.\n# allkeys-lfu -> Evict
    any key using approximated LFU.\n# volatile-random -> Remove a random key among
    the ones with an expire set.\n# allkeys-random -> Remove a random key, any key.\n#
    volatile-ttl -> Remove the key with the nearest expire time (minor TTL)\n# noeviction
    -> Don't evict anything, just return an error on write operations.\n#\n# LRU means
    Least Recently Used\n# LFU means Least Frequently Used\n#\n# Both LRU, LFU and
    volatile-ttl are implemented using approximated\n# randomized algorithms.\n#\n#
    Note: with any of the above policies, Redis will return an error on write\n#       operations,
    when there are no suitable keys for eviction.\n#\n#       At the date of writing
    these commands are: set setnx setex append\n#       incr decr rpush lpush rpushx
    lpushx linsert lset rpoplpush sadd\n#       sinter sinterstore sunion sunionstore
    sdiff sdiffstore zadd zincrby\n#       zunionstore zinterstore hset hsetnx hmset
    hincrby incrby decrby\n#       getset mset msetnx exec sort\n#\n# The default
    is:\n#\nmaxmemory-policy allkeys-lru \n\n# LRU, LFU and minimal TTL algorithms
    are not precise algorithms but approximated\n# algorithms (in order to save memory),
    so you can tune it for speed or\n# accuracy. For default Redis will check five
    keys and pick the one that was\n# used less recently, you can change the sample
    size using the following\n# configuration directive.\n#\n# The default of 5 produces
    good enough results. 10 Approximates very closely\n# true LRU but costs more CPU.
    3 is faster but not very accurate.\n#\n# maxmemory-samples 5\n\n#############################
    LAZY FREEING ####################################\n\n# Redis has two primitives
    to delete keys. One is called DEL and is a blocking\n# deletion of the object.
    It means that the server stops processing new commands\n# in order to reclaim
    all the memory associated with an object in a synchronous\n# way. If the key deleted
    is associated with a small object, the time needed\n# in order to execute the
    DEL command is very small and comparable to most other\n# O(1) or O(log_N) commands
    in Redis. However if the key is associated with an\n# aggregated value containing
    millions of elements, the server can block for\n# a long time (even seconds) in
    order to complete the operation.\n#\n# For the above reasons Redis also offers
    non blocking deletion primitives\n# such as UNLINK (non blocking DEL) and the
    ASYNC option of FLUSHALL and\n# FLUSHDB commands, in order to reclaim memory in
    background. Those commands\n# are executed in constant time. Another thread will
    incrementally free the\n# object in the background as fast as possible.\n#\n#
    DEL, UNLINK and ASYNC option of FLUSHALL and FLUSHDB are user-controlled.\n# It's
    up to the design of the application to understand when it is a good\n# idea to
    use one or the other. However the Redis server sometimes has to\n# delete keys
    or flush the whole database as a side effect of other operations.\n# Specifically
    Redis deletes objects independently of a user call in the\n# following scenarios:\n#\n#
    1) On eviction, because of the maxmemory and maxmemory policy configurations,\n#
    \   in order to make room for new data, without going over the specified\n#    memory
    limit.\n# 2) Because of expire: when a key with an associated time to live (see
    the\n#    EXPIRE command) must be deleted from memory.\n# 3) Because of a side
    effect of a command that stores data on a key that may\n#    already exist. For
    example the RENAME command may delete the old key\n#    content when it is replaced
    with another one. Similarly SUNIONSTORE\n#    or SORT with STORE option may delete
    existing keys. The SET command\n#    itself removes any old content of the specified
    key in order to replace\n#    it with the specified string.\n# 4) During replication,
    when a slave performs a full resynchronization with\n#    its master, the content
    of the whole database is removed in order to\n#    load the RDB file just transfered.\n#\n#
    In all the above cases the default is to delete objects in a blocking way,\n#
    like if DEL was called. However you can configure each case specifically\n# in
    order to instead release memory in a non-blocking way like if UNLINK\n# was called,
    using the following configuration directives:\n\nlazyfree-lazy-eviction no\nlazyfree-lazy-expire
    no\nlazyfree-lazy-server-del no\nslave-lazy-flush no\n\n##############################
    APPEND ONLY MODE ###############################\n\n# By default Redis asynchronously
    dumps the dataset on disk. This mode is\n# good enough in many applications, but
    an issue with the Redis process or\n# a power outage may result into a few minutes
    of writes lost (depending on\n# the configured save points).\n#\n# The Append
    Only File is an alternative persistence mode that provides\n# much better durability.
    For instance using the default data fsync policy\n# (see later in the config file)
    Redis can lose just one second of writes in a\n# dramatic event like a server
    power outage, or a single write if something\n# wrong with the Redis process itself
    happens, but the operating system is\n# still running correctly.\n#\n# AOF and
    RDB persistence can be enabled at the same time without problems.\n# If the AOF
    is enabled on startup Redis will load the AOF, that is the file\n# with the better
    durability guarantees.\n#\n# Please check http://redis.io/topics/persistence for
    more information.\n\nappendonly yes \n\n# The name of the append only file (default:
    \"appendonly.aof\")\n\nappendfilename \"appendonly.aof\"\n\n# The fsync() call
    tells the Operating System to actually write data on disk\n# instead of waiting
    for more data in the output buffer. Some OS will really flush\n# data on disk,
    some other OS will just try to do it ASAP.\n#\n# Redis supports three different
    modes:\n#\n# no: don't fsync, just let the OS flush the data when it wants. Faster.\n#
    always: fsync after every write to the append only log. Slow, Safest.\n# everysec:
    fsync only one time every second. Compromise.\n#\n# The default is \"everysec\",
    as that's usually the right compromise between\n# speed and data safety. It's
    up to you to understand if you can relax this to\n# \"no\" that will let the operating
    system flush the output buffer when\n# it wants, for better performances (but
    if you can live with the idea of\n# some data loss consider the default persistence
    mode that's snapshotting),\n# or on the contrary, use \"always\" that's very slow
    but a bit safer than\n# everysec.\n#\n# More details please check the following
    article:\n# http://antirez.com/post/redis-persistence-demystified.html\n#\n# If
    unsure, use \"everysec\".\n\n# appendfsync always\nappendfsync everysec\n# appendfsync
    no\n\n# When the AOF fsync policy is set to always or everysec, and a background\n#
    saving process (a background save or AOF log background rewriting) is\n# performing
    a lot of I/O against the disk, in some Linux configurations\n# Redis may block
    too long on the fsync() call. Note that there is no fix for\n# this currently,
    as even performing fsync in a different thread will block\n# our synchronous write(2)
    call.\n#\n# In order to mitigate this problem it's possible to use the following
    option\n# that will prevent fsync() from being called in the main process while
    a\n# BGSAVE or BGREWRITEAOF is in progress.\n#\n# This means that while another
    child is saving, the durability of Redis is\n# the same as \"appendfsync none\".
    In practical terms, this means that it is\n# possible to lose up to 30 seconds
    of log in the worst scenario (with the\n# default Linux settings).\n#\n# If you
    have latency problems turn this to \"yes\". Otherwise leave it as\n# \"no\" that
    is the safest pick from the point of view of durability.\n\nno-appendfsync-on-rewrite
    no\n\n# Automatic rewrite of the append only file.\n# Redis is able to automatically
    rewrite the log file implicitly calling\n# BGREWRITEAOF when the AOF log size
    grows by the specified percentage.\n#\n# This is how it works: Redis remembers
    the size of the AOF file after the\n# latest rewrite (if no rewrite has happened
    since the restart, the size of\n# the AOF at startup is used).\n#\n# This base
    size is compared to the current size. If the current size is\n# bigger than the
    specified percentage, the rewrite is triggered. Also\n# you need to specify a
    minimal size for the AOF file to be rewritten, this\n# is useful to avoid rewriting
    the AOF file even if the percentage increase\n# is reached but it is still pretty
    small.\n#\n# Specify a percentage of zero in order to disable the automatic AOF\n#
    rewrite feature.\n\nauto-aof-rewrite-percentage 100\nauto-aof-rewrite-min-size
    64mb\n\n# An AOF file may be found to be truncated at the end during the Redis\n#
    startup process, when the AOF data gets loaded back into memory.\n# This may happen
    when the system where Redis is running\n# crashes, especially when an ext4 filesystem
    is mounted without the\n# data=ordered option (however this can't happen when
    Redis itself\n# crashes or aborts but the operating system still works correctly).\n#\n#
    Redis can either exit with an error when this happens, or load as much\n# data
    as possible (the default now) and start if the AOF file is found\n# to be truncated
    at the end. The following option controls this behavior.\n#\n# If aof-load-truncated
    is set to yes, a truncated AOF file is loaded and\n# the Redis server starts emitting
    a log to inform the user of the event.\n# Otherwise if the option is set to no,
    the server aborts with an error\n# and refuses to start. When the option is set
    to no, the user requires\n# to fix the AOF file using the \"redis-check-aof\"
    utility before to restart\n# the server.\n#\n# Note that if the AOF file will
    be found to be corrupted in the middle\n# the server will still exit with an error.
    This option only applies when\n# Redis will try to read more data from the AOF
    file but not enough bytes\n# will be found.\naof-load-truncated yes\n\n# When
    rewriting the AOF file, Redis is able to use an RDB preamble in the\n# AOF file
    for faster rewrites and recoveries. When this option is turned\n# on the rewritten
    AOF file is composed of two different stanzas:\n#\n#   [RDB file][AOF tail]\n#\n#
    When loading Redis recognizes that the AOF file starts with the \"REDIS\"\n# string
    and loads the prefixed RDB file, and continues loading the AOF\n# tail.\n#\n#
    This is currently turned off by default in order to avoid the surprise\n# of a
    format change, but will at some point be used as the default.\naof-use-rdb-preamble
    no\n\n################################ LUA SCRIPTING  ###############################\n\n#
    Max execution time of a Lua script in milliseconds.\n#\n# If the maximum execution
    time is reached Redis will log that a script is\n# still in execution after the
    maximum allowed time and will start to\n# reply to queries with an error.\n#\n#
    When a long running script exceeds the maximum execution time only the\n# SCRIPT
    KILL and SHUTDOWN NOSAVE commands are available. The first can be\n# used to stop
    a script that did not yet called write commands. The second\n# is the only way
    to shut down the server in the case a write command was\n# already issued by the
    script but the user doesn't want to wait for the natural\n# termination of the
    script.\n#\n# Set it to 0 or a negative value for unlimited execution without
    warnings.\nlua-time-limit 5000\n\n################################ REDIS CLUSTER
    \ ###############################\n#\n# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n#
    WARNING EXPERIMENTAL: Redis Cluster is considered to be stable code, however\n#
    in order to mark it as \"mature\" we need to wait for a non trivial percentage\n#
    of users to deploy it in production.\n# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n#\n#
    Normal Redis instances can't be part of a Redis Cluster; only nodes that are\n#
    started as cluster nodes can. In order to start a Redis instance as a\n# cluster
    node enable the cluster support uncommenting the following:\n#\ncluster-enabled
    yes\n\n# Every cluster node has a cluster configuration file. This file is not\n#
    intended to be edited by hand. It is created and updated by Redis nodes.\n# Every
    Redis Cluster node requires a different cluster configuration file.\n# Make sure
    that instances running in the same system do not have\n# overlapping cluster configuration
    file names.\n#\ncluster-config-file nodes-6379.conf\n\n# Cluster node timeout
    is the amount of milliseconds a node must be unreachable\n# for it to be considered
    in failure state.\n# Most other internal time limits are multiple of the node
    timeout.\n#\ncluster-node-timeout 15000\n\n# A slave of a failing master will
    avoid to start a failover if its data\n# looks too old.\n#\n# There is no simple
    way for a slave to actually have an exact measure of\n# its \"data age\", so the
    following two checks are performed:\n#\n# 1) If there are multiple slaves able
    to failover, they exchange messages\n#    in order to try to give an advantage
    to the slave with the best\n#    replication offset (more data from the master
    processed).\n#    Slaves will try to get their rank by offset, and apply to the
    start\n#    of the failover a delay proportional to their rank.\n#\n# 2) Every
    single slave computes the time of the last interaction with\n#    its master.
    This can be the last ping or command received (if the master\n#    is still in
    the \"connected\" state), or the time that elapsed since the\n#    disconnection
    with the master (if the replication link is currently down).\n#    If the last
    interaction is too old, the slave will not try to failover\n#    at all.\n#\n#
    The point \"2\" can be tuned by user. Specifically a slave will not perform\n#
    the failover if, since the last interaction with the master, the time\n# elapsed
    is greater than:\n#\n#   (node-timeout * slave-validity-factor) + repl-ping-slave-period\n#\n#
    So for example if node-timeout is 30 seconds, and the slave-validity-factor\n#
    is 10, and assuming a default repl-ping-slave-period of 10 seconds, the\n# slave
    will not try to failover if it was not able to talk with the master\n# for longer
    than 310 seconds.\n#\n# A large slave-validity-factor may allow slaves with too
    old data to failover\n# a master, while a too small value may prevent the cluster
    from being able to\n# elect a slave at all.\n#\n# For maximum availability, it
    is possible to set the slave-validity-factor\n# to a value of 0, which means,
    that slaves will always try to failover the\n# master regardless of the last time
    they interacted with the master.\n# (However they'll always try to apply a delay
    proportional to their\n# offset rank).\n#\n# Zero is the only value able to guarantee
    that when all the partitions heal\n# the cluster will always be able to continue.\n#\n#
    cluster-slave-validity-factor 10\n\n# Cluster slaves are able to migrate to orphaned
    masters, that are masters\n# that are left without working slaves. This improves
    the cluster ability\n# to resist to failures as otherwise an orphaned master can't
    be failed over\n# in case of failure if it has no working slaves.\n#\n# Slaves
    migrate to orphaned masters only if there are still at least a\n# given number
    of other working slaves for their old master. This number\n# is the \"migration
    barrier\". A migration barrier of 1 means that a slave\n# will migrate only if
    there is at least 1 other working slave for its master\n# and so forth. It usually
    reflects the number of slaves you want for every\n# master in your cluster.\n#\n#
    Default is 1 (slaves migrate only if their masters remain with at least\n# one
    slave). To disable migration just set it to a very large value.\n# A value of
    0 can be set but is useful only for debugging and dangerous\n# in production.\n#\n#
    cluster-migration-barrier 1\n\n# By default Redis Cluster nodes stop accepting
    queries if they detect there\n# is at least an hash slot uncovered (no available
    node is serving it).\n# This way if the cluster is partially down (for example
    a range of hash slots\n# are no longer covered) all the cluster becomes, eventually,
    unavailable.\n# It automatically returns available as soon as all the slots are
    covered again.\n#\n# However sometimes you want the subset of the cluster which
    is working,\n# to continue to accept queries for the part of the key space that
    is still\n# covered. In order to do so, just set the cluster-require-full-coverage\n#
    option to no.\n#\n# cluster-require-full-coverage yes\n\n# In order to setup your
    cluster make sure to read the documentation\n# available at http://redis.io web
    site.\n\n########################## CLUSTER DOCKER/NAT support  ########################\n\n#
    In certain deployments, Redis Cluster nodes address discovery fails, because\n#
    addresses are NAT-ted or because ports are forwarded (the typical case is\n# Docker
    and other containers).\n#\n# In order to make Redis Cluster working in such environments,
    a static\n# configuration where each node knows its public address is needed.
    The\n# following two options are used for this scope, and are:\n#\n# * cluster-announce-ip\n#
    * cluster-announce-port\n# * cluster-announce-bus-port\n#\n# Each instruct the
    node about its address, client port, and cluster message\n# bus port. The information
    is then published in the header of the bus packets\n# so that other nodes will
    be able to correctly map the address of the node\n# publishing the information.\n#\n#
    If the above options are not used, the normal Redis Cluster auto-detection\n#
    will be used instead.\n#\n# Note that when remapped, the bus port may not be at
    the fixed offset of\n# clients port + 10000, so you can specify any port and bus-port
    depending\n# on how they get remapped. If the bus-port is not set, a fixed offset
    of\n# 10000 will be used as usually.\n#\n# Example:\n#\n# cluster-announce-ip
    10.1.1.5\n# cluster-announce-port 6379\n# cluster-announce-bus-port 6380\n\n##################################
    SLOW LOG ###################################\n\n# The Redis Slow Log is a system
    to log queries that exceeded a specified\n# execution time. The execution time
    does not include the I/O operations\n# like talking with the client, sending the
    reply and so forth,\n# but just the time needed to actually execute the command
    (this is the only\n# stage of command execution where the thread is blocked and
    can not serve\n# other requests in the meantime).\n#\n# You can configure the
    slow log with two parameters: one tells Redis\n# what is the execution time, in
    microseconds, to exceed in order for the\n# command to get logged, and the other
    parameter is the length of the\n# slow log. When a new command is logged the oldest
    one is removed from the\n# queue of logged commands.\n\n# The following time is
    expressed in microseconds, so 1000000 is equivalent\n# to one second. Note that
    a negative number disables the slow log, while\n# a value of zero forces the logging
    of every command.\nslowlog-log-slower-than 10000\n\n# There is no limit to this
    length. Just be aware that it will consume memory.\n# You can reclaim memory used
    by the slow log with SLOWLOG RESET.\nslowlog-max-len 128\n\n################################
    LATENCY MONITOR ##############################\n\n# The Redis latency monitoring
    subsystem samples different operations\n# at runtime in order to collect data
    related to possible sources of\n# latency of a Redis instance.\n#\n# Via the LATENCY
    command this information is available to the user that can\n# print graphs and
    obtain reports.\n#\n# The system only logs operations that were performed in a
    time equal or\n# greater than the amount of milliseconds specified via the\n#
    latency-monitor-threshold configuration directive. When its value is set\n# to
    zero, the latency monitor is turned off.\n#\n# By default latency monitoring is
    disabled since it is mostly not needed\n# if you don't have latency issues, and
    collecting data has a performance\n# impact, that while very small, can be measured
    under big load. Latency\n# monitoring can easily be enabled at runtime using the
    command\n# \"CONFIG SET latency-monitor-threshold <milliseconds>\" if needed.\nlatency-monitor-threshold
    0\n\n############################# EVENT NOTIFICATION ##############################\n\n#
    Redis can notify Pub/Sub clients about events happening in the key space.\n# This
    feature is documented at http://redis.io/topics/notifications\n#\n# For instance
    if keyspace events notification is enabled, and a client\n# performs a DEL operation
    on key \"foo\" stored in the Database 0, two\n# messages will be published via
    Pub/Sub:\n#\n# PUBLISH __keyspace@0__:foo del\n# PUBLISH __keyevent@0__:del foo\n#\n#
    It is possible to select the events that Redis will notify among a set\n# of classes.
    Every class is identified by a single character:\n#\n#  K     Keyspace events,
    published with __keyspace@<db>__ prefix.\n#  E     Keyevent events, published
    with __keyevent@<db>__ prefix.\n#  g     Generic commands (non-type specific)
    like DEL, EXPIRE, RENAME, ...\n#  $     String commands\n#  l     List commands\n#
    \ s     Set commands\n#  h     Hash commands\n#  z     Sorted set commands\n#
    \ x     Expired events (events generated every time a key expires)\n#  e     Evicted
    events (events generated when a key is evicted for maxmemory)\n#  A     Alias
    for g$lshzxe, so that the \"AKE\" string means all the events.\n#\n#  The \"notify-keyspace-events\"
    takes as argument a string that is composed\n#  of zero or multiple characters.
    The empty string means that notifications\n#  are disabled.\n#\n#  Example: to
    enable list and generic events, from the point of view of the\n#           event
    name, use:\n#\n#  notify-keyspace-events Elg\n#\n#  Example 2: to get the stream
    of the expired keys subscribing to channel\n#             name __keyevent@0__:expired
    use:\n#\n#  notify-keyspace-events Ex\n#\n#  By default all notifications are
    disabled because most users don't need\n#  this feature and the feature has some
    overhead. Note that if you don't\n#  specify at least one of K or E, no events
    will be delivered.\nnotify-keyspace-events \"\"\n\n###############################
    ADVANCED CONFIG ###############################\n\n# Hashes are encoded using
    a memory efficient data structure when they have a\n# small number of entries,
    and the biggest entry does not exceed a given\n# threshold. These thresholds can
    be configured using the following directives.\nhash-max-ziplist-entries 512\nhash-max-ziplist-value
    64\n\n# Lists are also encoded in a special way to save a lot of space.\n# The
    number of entries allowed per internal list node can be specified\n# as a fixed
    maximum size or a maximum number of elements.\n# For a fixed maximum size, use
    -5 through -1, meaning:\n# -5: max size: 64 Kb  <-- not recommended for normal
    workloads\n# -4: max size: 32 Kb  <-- not recommended\n# -3: max size: 16 Kb  <--
    probably not recommended\n# -2: max size: 8 Kb   <-- good\n# -1: max size: 4 Kb
    \  <-- good\n# Positive numbers mean store up to _exactly_ that number of elements\n#
    per list node.\n# The highest performing option is usually -2 (8 Kb size) or -1
    (4 Kb size),\n# but if your use case is unique, adjust the settings as necessary.\nlist-max-ziplist-size
    -2\n\n# Lists may also be compressed.\n# Compress depth is the number of quicklist
    ziplist nodes from *each* side of\n# the list to *exclude* from compression.  The
    head and tail of the list\n# are always uncompressed for fast push/pop operations.
    \ Settings are:\n# 0: disable all list compression\n# 1: depth 1 means \"don't
    start compressing until after 1 node into the list,\n#    going from either the
    head or tail\"\n#    So: [head]->node->node->...->node->[tail]\n#    [head], [tail]
    will always be uncompressed; inner nodes will compress.\n# 2: [head]->[next]->node->node->...->node->[prev]->[tail]\n#
    \   2 here means: don't compress head or head->next or tail->prev or tail,\n#
    \   but compress all nodes between them.\n# 3: [head]->[next]->[next]->node->node->...->node->[prev]->[prev]->[tail]\n#
    etc.\nlist-compress-depth 0\n\n# Sets have a special encoding in just one case:
    when a set is composed\n# of just strings that happen to be integers in radix
    10 in the range\n# of 64 bit signed integers.\n# The following configuration setting
    sets the limit in the size of the\n# set in order to use this special memory saving
    encoding.\nset-max-intset-entries 512\n\n# Similarly to hashes and lists, sorted
    sets are also specially encoded in\n# order to save a lot of space. This encoding
    is only used when the length and\n# elements of a sorted set are below the following
    limits:\nzset-max-ziplist-entries 128\nzset-max-ziplist-value 64\n\n# HyperLogLog
    sparse representation bytes limit. The limit includes the\n# 16 bytes header.
    When an HyperLogLog using the sparse representation crosses\n# this limit, it
    is converted into the dense representation.\n#\n# A value greater than 16000 is
    totally useless, since at that point the\n# dense representation is more memory
    efficient.\n#\n# The suggested value is ~ 3000 in order to have the benefits of\n#
    the space efficient encoding without slowing down too much PFADD,\n# which is
    O(N) with the sparse encoding. The value can be raised to\n# ~ 10000 when CPU
    is not a concern, but space is, and the data set is\n# composed of many HyperLogLogs
    with cardinality in the 0 - 15000 range.\nhll-sparse-max-bytes 3000\n\n# Active
    rehashing uses 1 millisecond every 100 milliseconds of CPU time in\n# order to
    help rehashing the main Redis hash table (the one mapping top-level\n# keys to
    values). The hash table implementation Redis uses (see dict.c)\n# performs a lazy
    rehashing: the more operation you run into a hash table\n# that is rehashing,
    the more rehashing \"steps\" are performed, so if the\n# server is idle the rehashing
    is never complete and some more memory is used\n# by the hash table.\n#\n# The
    default is to use this millisecond 10 times every second in order to\n# actively
    rehash the main dictionaries, freeing memory when possible.\n#\n# If unsure:\n#
    use \"activerehashing no\" if you have hard latency requirements and it is\n#
    not a good thing in your environment that Redis can reply from time to time\n#
    to queries with 2 milliseconds delay.\n#\n# use \"activerehashing yes\" if you
    don't have such hard requirements but\n# want to free memory asap when possible.\nactiverehashing
    yes\n\n# The client output buffer limits can be used to force disconnection of
    clients\n# that are not reading data from the server fast enough for some reason
    (a\n# common reason is that a Pub/Sub client can't consume messages as fast as
    the\n# publisher can produce them).\n#\n# The limit can be set differently for
    the three different classes of clients:\n#\n# normal -> normal clients including
    MONITOR clients\n# slave  -> slave clients\n# pubsub -> clients subscribed to
    at least one pubsub channel or pattern\n#\n# The syntax of every client-output-buffer-limit
    directive is the following:\n#\n# client-output-buffer-limit <class> <hard limit>
    <soft limit> <soft seconds>\n#\n# A client is immediately disconnected once the
    hard limit is reached, or if\n# the soft limit is reached and remains reached
    for the specified number of\n# seconds (continuously).\n# So for instance if the
    hard limit is 32 megabytes and the soft limit is\n# 16 megabytes / 10 seconds,
    the client will get disconnected immediately\n# if the size of the output buffers
    reach 32 megabytes, but will also get\n# disconnected if the client reaches 16
    megabytes and continuously overcomes\n# the limit for 10 seconds.\n#\n# By default
    normal clients are not limited because they don't receive data\n# without asking
    (in a push way), but just after a request, so only\n# asynchronous clients may
    create a scenario where data is requested faster\n# than it can read.\n#\n# Instead
    there is a default limit for pubsub and slave clients, since\n# subscribers and
    slaves receive data in a push fashion.\n#\n# Both the hard or the soft limit can
    be disabled by setting them to zero.\nclient-output-buffer-limit normal 0 0 0\nclient-output-buffer-limit
    slave 256mb 64mb 60\nclient-output-buffer-limit pubsub 32mb 8mb 60\n\n# Client
    query buffers accumulate new commands. They are limited to a fixed\n# amount by
    default in order to avoid that a protocol desynchronization (for\n# instance due
    to a bug in the client) will lead to unbound memory usage in\n# the query buffer.
    However you can configure it here if you have very special\n# needs, such us huge
    multi/exec requests or alike.\n#\n# client-query-buffer-limit 1gb\n\n# In the
    Redis protocol, bulk requests, that are, elements representing single\n# strings,
    are normally limited ot 512 mb. However you can change this limit\n# here.\n#\n#
    proto-max-bulk-len 512mb\n\n# Redis calls an internal function to perform many
    background tasks, like\n# closing connections of clients in timeout, purging expired
    keys that are\n# never requested, and so forth.\n#\n# Not all tasks are performed
    with the same frequency, but Redis checks for\n# tasks to perform according to
    the specified \"hz\" value.\n#\n# By default \"hz\" is set to 10. Raising the
    value will use more CPU when\n# Redis is idle, but at the same time will make
    Redis more responsive when\n# there are many keys expiring at the same time, and
    timeouts may be\n# handled with more precision.\n#\n# The range is between 1 and
    500, however a value over 100 is usually not\n# a good idea. Most users should
    use the default of 10 and raise this up to\n# 100 only in environments where very
    low latency is required.\nhz 10\n\n# When a child rewrites the AOF file, if the
    following option is enabled\n# the file will be fsync-ed every 32 MB of data generated.
    This is useful\n# in order to commit the file to the disk more incrementally and
    avoid\n# big latency spikes.\naof-rewrite-incremental-fsync yes\n\n# Redis LFU
    eviction (see maxmemory setting) can be tuned. However it is a good\n# idea to
    start with the default settings and only change them after investigating\n# how
    to improve the performances and how the keys LFU change over time, which\n# is
    possible to inspect via the OBJECT FREQ command.\n#\n# There are two tunable parameters
    in the Redis LFU implementation: the\n# counter logarithm factor and the counter
    decay time. It is important to\n# understand what the two parameters mean before
    changing them.\n#\n# The LFU counter is just 8 bits per key, it's maximum value
    is 255, so Redis\n# uses a probabilistic increment with logarithmic behavior.
    Given the value\n# of the old counter, when a key is accessed, the counter is
    incremented in\n# this way:\n#\n# 1. A random number R between 0 and 1 is extracted.\n#
    2. A probability P is calculated as 1/(old_value*lfu_log_factor+1).\n# 3. The
    counter is incremented only if R < P.\n#\n# The default lfu-log-factor is 10.
    This is a table of how the frequency\n# counter changes with a different number
    of accesses with different\n# logarithmic factors:\n#\n# +--------+------------+------------+------------+------------+------------+\n#
    | factor | 100 hits   | 1000 hits  | 100K hits  | 1M hits    | 10M hits   |\n#
    +--------+------------+------------+------------+------------+------------+\n#
    | 0      | 104        | 255        | 255        | 255        | 255        |\n#
    +--------+------------+------------+------------+------------+------------+\n#
    | 1      | 18         | 49         | 255        | 255        | 255        |\n#
    +--------+------------+------------+------------+------------+------------+\n#
    | 10     | 10         | 18         | 142        | 255        | 255        |\n#
    +--------+------------+------------+------------+------------+------------+\n#
    | 100    | 8          | 11         | 49         | 143        | 255        |\n#
    +--------+------------+------------+------------+------------+------------+\n#\n#
    NOTE: The above table was obtained by running the following commands:\n#\n#   redis-benchmark
    -n 1000000 incr foo\n#   redis-cli object freq foo\n#\n# NOTE 2: The counter initial
    value is 5 in order to give new objects a chance\n# to accumulate hits.\n#\n#
    The counter decay time is the time, in minutes, that must elapse in order\n# for
    the key counter to be divided by two (or decremented if it has a value\n# less
    <= 10).\n#\n# The default value for the lfu-decay-time is 1. A Special value of
    0 means to\n# decay the counter every time it happens to be scanned.\n#\n# lfu-log-factor
    10\n# lfu-decay-time 1\n\n########################### ACTIVE DEFRAGMENTATION #######################\n#\n#
    WARNING THIS FEATURE IS EXPERIMENTAL. However it was stress tested\n# even in
    production and manually tested by multiple engineers for some\n# time.\n#\n# What
    is active defragmentation?\n# -------------------------------\n#\n# Active (online)
    defragmentation allows a Redis server to compact the\n# spaces left between small
    allocations and deallocations of data in memory,\n# thus allowing to reclaim back
    memory.\n#\n# Fragmentation is a natural process that happens with every allocator
    (but\n# less so with Jemalloc, fortunately) and certain workloads. Normally a
    server\n# restart is needed in order to lower the fragmentation, or at least to
    flush\n# away all the data and create it again. However thanks to this feature\n#
    implemented by Oran Agra for Redis 4.0 this process can happen at runtime\n# in
    an \"hot\" way, while the server is running.\n#\n# Basically when the fragmentation
    is over a certain level (see the\n# configuration options below) Redis will start
    to create new copies of the\n# values in contiguous memory regions by exploiting
    certain specific Jemalloc\n# features (in order to understand if an allocation
    is causing fragmentation\n# and to allocate it in a better place), and at the
    same time, will release the\n# old copies of the data. This process, repeated
    incrementally for all the keys\n# will cause the fragmentation to drop back to
    normal values.\n#\n# Important things to understand:\n#\n# 1. This feature is
    disabled by default, and only works if you compiled Redis\n#    to use the copy
    of Jemalloc we ship with the source code of Redis.\n#    This is the default with
    Linux builds.\n#\n# 2. You never need to enable this feature if you don't have
    fragmentation\n#    issues.\n#\n# 3. Once you experience fragmentation, you can
    enable this feature when\n#    needed with the command \"CONFIG SET activedefrag
    yes\".\n#\n# The configuration parameters are able to fine tune the behavior of
    the\n# defragmentation process. If you are not sure about what they mean it is\n#
    a good idea to leave the defaults untouched.\n\n# Enabled active defragmentation\n#
    activedefrag yes\n\n# Minimum amount of fragmentation waste to start active defrag\n#
    active-defrag-ignore-bytes 100mb\n\n# Minimum percentage of fragmentation to start
    active defrag\n# active-defrag-threshold-lower 10\n\n# Maximum percentage of fragmentation
    at which we use maximum effort\n# active-defrag-threshold-upper 100\n\n# Minimal
    effort for defrag in CPU percentage\n# active-defrag-cycle-min 25\n\n# Maximal
    effort for defrag in CPU percentage\n# active-defrag-cycle-max 75\n\n"
kind: ConfigMap
metadata:
  name: statefulset-redis-config

---
# statefulset
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: statefulset-redis
spec:
  replicas: 6
  serviceName: statefulset-redis-headless-service
  selector:
    matchLabels:
      app: statefulset-redis
  volumeClaimTemplates:
  - metadata:
      name: statefulset-redis-data
    spec:
      accessModes: 
      - ReadWriteOnce
      storageClassName: storage-class-pvc
      resources:
        requests:
          storage: 1Gi
  template:
    metadata:
      labels:
        app: statefulset-redis
    spec:
      volumes:
      - name: redis-config
        configMap: 
          name: statefulset-redis-config
      containers:
      - name: stateful-redis-container
        image: registry.local:5000/redis/v1
        imagePullPolicy: IfNotPresent
        volumeMounts:
        - name: redis-config
          #readOnly: true
          mountPath: /etc/redis/conf.d
        - name: statefulset-redis-data
          mountPath: /var/run/redis/data
        env:
        - name: SERVER_PORT
          valueFrom:
            configMapKeyRef:
              name: statefulset-redis-config
              key: port
        - name: CLUSTER_REPLICAS 
          value: "6"
        #command:
        #- "/bin/bash"
        #- "-c"
        #- |
        #  while true
        #  do
        #    rm -f /var/run/redis/data/*
        #    sleep 10
        #  done
        readinessProbe:
          exec: 
            command: ["netstat", "-tn", "|", "grep", "$SERVER_PORT"]
        command:
        - "/bin/bash"
        - "-c"
        - |
          rm -f /var/run/redis/data/*
          /home/work/programs/redis-4.0.8/src/redis-server /etc/redis/conf.d/redis.config 
          BUILD_CLUSTER_COMMAND="/home/work/programs/redis-4.0.8/src/redis-trib.rb create --replicas 1"
          INDEX=${HOSTNAME##*-}
          if [ $INDEX -eq  `expr $CLUSTER_REPLICAS - 1` ]; then
            for((i=0; i<$CLUSTER_REPLICAS; i++))
            do
              ip=$(ping -c 1 statefulset-redis-$i.statefulset-redis-headless-service.default.svc.cluster.local|grep icmp_seq=1|awk -F "(" '{print $2}'|awk -F ")" '{print $1}')
              BUILD_CLUSTER_COMMAND=$BUILD_CLUSTER_COMMAND" ${ip}:6379"
            done
            echo $BUILD_CLUSTER_COMMAND
            echo "yes" > /tmp/yes
            $BUILD_CLUSTER_COMMAND < /tmp/yes
            rm -f /tmp/yes
          fi
          while true
          do
            sleep 3
          done
